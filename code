import cv2
import numpy as np
import mediapipe as mp
from collections import deque
from datetime import datetime
import threading
import sys

# Initialize MediaPipe
mp_hands = mp.solutions.hands
mp_drawing = mp.solutions.drawing_utils
hands = mp_hands.Hands(
    static_image_mode=False,
    max_num_hands=1,
    min_detection_confidence=0.5,
    min_tracking_confidence=0.5
)

# Initialize Face Detection for drowsiness detection
mp_face_detection = mp.solutions.face_detection
face_detection = mp_face_detection.FaceDetection(min_detection_confidence=0.5)

mp_face_mesh = mp.solutions.face_mesh
face_mesh = mp_face_mesh.FaceMesh(
    static_image_mode=False,
    max_num_faces=1,
    min_detection_confidence=0.5,
    min_tracking_confidence=0.5
)

# Color palette (BGR format for OpenCV)
COLORS = {
    'red': (0, 0, 255),
    'blue': (255, 0, 0),
    'green': (0, 255, 0),
    'yellow': (0, 255, 255),
    'white': (255, 255, 255)
}

ERASER_SIZE_OPTIONS = [5, 10, 20, 30, 50]

class AirCanvas:
    def __init__(self):
        self.cap = cv2.VideoCapture(0)
        self.canvas = None
        self.drawing = False
        self.current_color = 'red'
        self.current_color_rgb = COLORS['red']
        self. brush_size = 5
        self.eraser_size = 10
        self.is_erasing = False
        
        # Store drawing points
        self.points_deque = deque(maxlen=512)
        
        # Drowsiness detection variables
        self. eye_closure_counter = 0
        self.eye_closure_threshold = 30
        self.is_drowsy = False
        self.sleep_detected = False
        self.blink_count = 0
        
        # Frame dimensions
        self.frame_width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        self.frame_height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        
        # Initialize canvas
        self.canvas = np. ones((self.frame_height, self.frame_width, 3), dtype="uint8") * 255
        
        # UI Variables
        self.show_menu = True
        self.ui_height = 100
        
    def get_distance(self, point1, point2):
        """Calculate distance between two points"""
        return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)
    
    def is_hand_open(self, landmarks):
        """Detect if hand is open (for erasing) or closed (for drawing)"""
        # If distance between thumb and index finger is large, hand is open
        thumb = landmarks[4]
        index = landmarks[8]
        distance = self.get_distance(thumb, index)
        return distance > 0.05
    
    def detect_drowsiness(self, frame):
        """Detect drowsiness and sleep based on eye closure"""
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = face_mesh.process(rgb_frame)
        
        if results.multi_face_landmarks:
            landmarks = results. multi_face_landmarks[0]. landmark
            
            # Eye landmarks:  left eye (33, 160, 158, 133), right eye (362, 385, 387, 263)
            left_eye_top = landmarks[159]. y
            left_eye_bottom = landmarks[145].y
            right_eye_top = landmarks[386].y
            right_eye_bottom = landmarks[374].y
            
            # Calculate eye aspect ratio
            left_eye_distance = abs(left_eye_top - left_eye_bottom)
            right_eye_distance = abs(right_eye_top - right_eye_bottom)
            avg_eye_distance = (left_eye_distance + right_eye_distance) / 2
            
            # If eyes are closed
            if avg_eye_distance < 0.01:
                self.eye_closure_counter += 1
                if self.eye_closure_counter > self.eye_closure_threshold:
                    self.is_drowsy = True
                    if self.eye_closure_counter > self.eye_closure_threshold * 2:
                        self. sleep_detected = True
            else:
                self.eye_closure_counter = 0
                self.is_drowsy = False
                self.sleep_detected = False
    
    def draw_ui(self, frame):
        """Draw user interface menu"""
        # Create UI background
        cv2.rectangle(frame, (0, 0), (self.frame_width, self.ui_height), (200, 200, 200), -1)
        
        # Display current settings
        text_y = 30
        cv2.putText(frame, f"Color: {self.current_color. upper()}", (10, text_y),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)
        cv2.putText(frame, f"Brush: {self.brush_size}", (250, text_y),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)
        cv2.putText(frame, f"Eraser:  {self.eraser_size}", (450, text_y),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)
        
        # Display status
        status_text = "ASLEEP" if self.sleep_detected else ("DROWSY" if self.is_drowsy else "AWAKE")
        status_color = (0, 0, 255) if self.sleep_detected else ((0, 165, 255) if self.is_drowsy else (0, 255, 0))
        cv2.putText(frame, f"Status: {status_text}", (700, text_y),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, status_color, 2)
        
        # Display instructions
        cv2.putText(frame, "Keys:  R/B/G/Y/W(color) | +/-(brush) | E/D(eraser) | C(clear) | Q(quit)",
                    (10, self.ui_height - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1)
    
    def clear_canvas(self):
        """Clear the canvas"""
        self. canvas = np.ones((self. frame_height, self.frame_width, 3), dtype="uint8") * 255
    
    def run(self):
        """Main run loop"""
        print("\n=== Air Canvas Application ===")
        print("Controls:")
        print("  R/B/G/Y/W - Change color (Red/Blue/Green/Yellow/White)")
        print("  +/- - Increase/Decrease brush size")
        print("  E - Eraser mode")
        print("  D - Drawing mode")
        print("  C - Clear canvas")
        print("  Q - Quit")
        print("\nDrowsiness Detection:  Green=Awake, Orange=Drowsy, Red=Asleep")
        print("\n" + "="*35 + "\n")
        
        while True:
            ret, frame = self.cap.read()
            if not ret:
                break
            
            # Flip frame for selfie view
            frame = cv2.flip(frame, 1)
            
            # Convert to RGB for MediaPipe
            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            
            # Detect hands
            hand_results = hands.process(rgb_frame)
            
            # Detect drowsiness
            self.detect_drowsiness(frame)
            
            # Draw canvas on frame
            frame = cv2.addWeighted(frame, 0.3, self.canvas, 0.7, 0)
            
            # Process hand landmarks
            if hand_results. multi_hand_landmarks:
                for hand_landmarks in hand_results.multi_hand_landmarks:
                    # Get index finger tip position
                    index_finger = hand_landmarks.landmark[8]
                    x = int(index_finger.x * self.frame_width)
                    y = int(index_finger.y * self.frame_height)
                    
                    # Check if hand is open (erasing) or closed (drawing)
                    if self.is_hand_open(hand_landmarks. landmark):
                        self.is_erasing = True
                    else:
                        self.is_erasing = False
                    
                    # Draw on canvas
                    if self.is_erasing:
                        # Eraser mode
                        cv2.circle(self.canvas, (x, y), self.eraser_size, (255, 255, 255), -1)
                        cv2.circle(frame, (x, y), self.eraser_size, (0, 255, 0), 2)
                    else:
                        # Drawing mode
                        cv2.circle(self.canvas, (x, y), self.brush_size, self.current_color_rgb, -1)
                        cv2.circle(frame, (x, y), self.brush_size, self.current_color_rgb, 2)
                    
                    # Draw hand landmarks
                    mp_drawing.draw_landmarks(frame, hand_landmarks, mp_hands.HAND_CONNECTIONS)
            
            # Draw UI
            self.draw_ui(frame)
            
            # Display frame
            cv2.imshow('Air Canvas', frame)
            
            # Handle keyboard input
            key = cv2.waitKey(1) & 0xFF
            
            if key == ord('q'):
                break
            elif key == ord('c'):
                self.clear_canvas()
                print("Canvas cleared!")
            elif key == ord('r'):
                self.current_color = 'red'
                self.current_color_rgb = COLORS['red']
                print("Color:  RED")
            elif key == ord('b'):
                self.current_color = 'blue'
                self.current_color_rgb = COLORS['blue']
                print("Color: BLUE")
            elif key == ord('g'):
                self.current_color = 'green'
                self.current_color_rgb = COLORS['green']
                print("Color:  GREEN")
            elif key == ord('y'):
                self.current_color = 'yellow'
                self.current_color_rgb = COLORS['yellow']
                print("Color: YELLOW")
            elif key == ord('w'):
                self.current_color = 'white'
                self. current_color_rgb = COLORS['white']
                print("Color: WHITE")
            elif key == ord('+') or key == ord('='):
                self.brush_size = min(50, self.brush_size + 2)
                print(f"Brush size:  {self.brush_size}")
            elif key == ord('-') or key == ord('_'):
                self.brush_size = max(1, self.brush_size - 2)
                print(f"Brush size: {self.brush_size}")
            elif key == ord('e'):
                self.is_erasing = True
                print("Eraser mode ON")
            elif key == ord('d'):
                self.is_erasing = False
                print("Drawing mode ON")
            elif key == ord('['):
                idx = ERASER_SIZE_OPTIONS.index(self.eraser_size) if self.eraser_size in ERASER_SIZE_OPTIONS else 0
                self.eraser_size = ERASER_SIZE_OPTIONS[max(0, idx - 1)]
                print(f"Eraser size: {self.eraser_size}")
            elif key == ord(']'):
                idx = ERASER_SIZE_OPTIONS.index(self.eraser_size) if self.eraser_size in ERASER_SIZE_OPTIONS else 0
                self. eraser_size = ERASER_SIZE_OPTIONS[min(len(ERASER_SIZE_OPTIONS) - 1, idx + 1)]
                print(f"Eraser size: {self.eraser_size}")
        
        self.cleanup()
    
    def cleanup(self):
        """Clean up resources"""
        self.cap.release()
        cv2.destroyAllWindows()
        print("\nApplication closed.  Thank you for using Air Canvas!")

if __name__ == "__main__": 
    try:
        air_canvas = AirCanvas()
        air_canvas.run()
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
